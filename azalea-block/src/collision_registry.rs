//! Runtime collision shape registry for modded blocks.
//!
//! This module provides a way to register collision shapes for modded blocks
//! at runtime, since the autogenerated collision data only includes vanilla blocks.

use std::collections::HashMap;
use std::sync::RwLock;

/// A simple collision shape representation.
///
/// For now, we only support empty and full cube shapes, which covers most
/// modded blocks. Complex shapes can be added later if needed.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SimpleCollisionShape {
    /// Empty collision shape (like air, tall grass)
    Empty,
    /// Full cube collision shape (like stone, dirt)
    Full,
}

impl SimpleCollisionShape {
    /// Returns true if this shape is empty.
    pub fn is_empty(&self) -> bool {
        matches!(self, Self::Empty)
    }

    /// Returns true if this shape is a full cube.
    pub fn is_full(&self) -> bool {
        matches!(self, Self::Full)
    }
}

/// Runtime registry for modded block collision shapes.
///
/// This is a global registry that can be populated at runtime with collision
/// data for modded blocks. The physics system will check this registry for
/// block state IDs that are out of range of the vanilla collision data.
static MODDED_COLLISION_SHAPES: RwLock<Option<HashMap<u32, SimpleCollisionShape>>> =
    RwLock::new(None);

/// Initialize the modded collision shapes registry.
///
/// This must be called before [`register_modded_collision_shape`].
pub fn init_modded_collision_registry() {
    let mut registry = MODDED_COLLISION_SHAPES.write().unwrap();
    if registry.is_none() {
        *registry = Some(HashMap::new());
    }
}

/// Register a collision shape for a modded block state ID.
///
/// # Arguments
/// * `state_id` - The block state ID (must be above vanilla MAX_STATE)
/// * `shape` - The collision shape for this block
///
/// # Panics
/// Panics if the registry hasn't been initialized with
/// [`init_modded_collision_registry`].
pub fn register_modded_collision_shape(state_id: u32, shape: SimpleCollisionShape) {
    let mut registry = MODDED_COLLISION_SHAPES.write().unwrap();
    let registry = registry.as_mut().expect(
        "Modded collision registry not initialized. Call init_modded_collision_registry() first.",
    );
    registry.insert(state_id, shape);
}

/// Register collision shapes for multiple modded block state IDs.
///
/// # Arguments
/// * `shapes` - An iterator of (state_id, shape) pairs
///
/// # Panics
/// Panics if the registry hasn't been initialized.
pub fn register_modded_collision_shapes<I>(shapes: I)
where
    I: IntoIterator<Item = (u32, SimpleCollisionShape)>,
{
    let mut registry = MODDED_COLLISION_SHAPES.write().unwrap();
    let registry = registry.as_mut().expect(
        "Modded collision registry not initialized. Call init_modded_collision_registry() first.",
    );

    for (state_id, shape) in shapes {
        registry.insert(state_id, shape);
    }
}

/// Get the collision shape for a modded block state ID.
///
/// Returns `None` if the state ID is not registered.
pub fn get_modded_collision_shape(state_id: u32) -> Option<SimpleCollisionShape> {
    let registry = MODDED_COLLISION_SHAPES.read().unwrap();
    registry.as_ref().and_then(|r| r.get(&state_id).copied())
}

/// Check if a modded block state ID has an empty collision shape.
///
/// Returns `None` if the state ID is not registered.
pub fn is_modded_block_collision_empty(state_id: u32) -> Option<bool> {
    get_modded_collision_shape(state_id).map(|s| s.is_empty())
}

/// Check if a modded block state ID has a full collision shape.
///
/// Returns `None` if the state ID is not registered.
pub fn is_modded_block_collision_full(state_id: u32) -> Option<bool> {
    get_modded_collision_shape(state_id).map(|s| s.is_full())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_register_and_get() {
        init_modded_collision_registry();

        register_modded_collision_shape(30000, SimpleCollisionShape::Empty);
        register_modded_collision_shape(30001, SimpleCollisionShape::Full);

        assert_eq!(
            get_modded_collision_shape(30000),
            Some(SimpleCollisionShape::Empty)
        );
        assert_eq!(
            get_modded_collision_shape(30001),
            Some(SimpleCollisionShape::Full)
        );
        assert_eq!(get_modded_collision_shape(30002), None);

        assert_eq!(is_modded_block_collision_empty(30000), Some(true));
        assert_eq!(is_modded_block_collision_empty(30001), Some(false));
        assert_eq!(is_modded_block_collision_full(30000), Some(false));
        assert_eq!(is_modded_block_collision_full(30001), Some(true));
    }
}
